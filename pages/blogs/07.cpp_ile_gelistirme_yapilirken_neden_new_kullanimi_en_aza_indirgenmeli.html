<!doctype html>
<html lang="tr">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description"
    content="Kaan Can it'in portf繹y sitesi. Projeler, blog yaz覺lar覺, tasar覺mlar ve daha fazlas覺...">
  <meta name="author" content="Kaan Can it">

  <title>Kaan Can it</title>
  <link rel="icon" href="/images/base_site_images/designPng.webp" type="image/x-icon" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <link rel="stylesheet" href="/css/base-site.css">
  <link rel="stylesheet" href="/css/tooplate-style.css">

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-2BLQV2M3JL"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-2BLQV2M3JL');
  </script>
</head>

<body>
  <div id="loader" class="loader-light">
    <div class="dot"></div>
    <div class="dot"></div>
    <div class="dot"></div>
    <div class="dot"></div>
  </div>

  <nav class="navbar navbar-expand-sm navbar-light">
    <div class="container-fluid">
      <a class="navbar-brand" href="../../index.html"> Kaan Can it</a>

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
        aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
        <span class="navbar-toggler-icon"></span>
        <span class="navbar-toggler-icon"></span>
      </button>

      <div style="background-color: transparent;" class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav mx-auto">
          <li class="nav-item"><a href="../projects.html" class="nav-link">Projeler</a></li>
          <li class="nav-item"><a href="../main_blog_page.html" class="nav-link">Blog</a></li>
          <li class="nav-item"><a href="../design.html" class="nav-link">Tasar覺m</a></li>
          <li class="nav-item"><a href="../about_me.html" class="nav-link">Hakk覺nda</a></li>
          <li class="nav-item"><a href="#contact" class="nav-link">襤letiim</a></li>
          <li class="nav-item"><a href="../hayat_anlam_katanlar_manifestosu.html" class="nav-link"></a></li>
        </ul>
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link"><span class="color-mode color-mode-icon"></span></a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <!-- Blog -->
  <section class="full-screen" id="project">
    <div class="container row">
      <img src="../../images/blogs/C++_Ile_Gelistirme_Yap._Neden_new_En_Aza_Ind/header_image.webp" class="img-fluid">
      <div class="col-lg-12 mx-auto">
        <h2>C++ 襤le Gelitirme Yap覺l覺rken Neden "new" Kullan覺m覺 En Aza 襤ndirgenmeli?</h2>
        <p><small>Mart 12, 2023</small></p>
        <p>
          Merhaba, bug羹n C++ dilinde "new" kullan覺m覺n覺n arkas覺nda neler olduuna dair bir bak覺 ataca覺z. C++ ve C
          donan覺m tabanl覺 bir癟ok ama癟 i癟in kullan覺labilen dillerdir ve bellek y繹netimi konusunda biraz daha a癟覺k yaz覺m
          yap覺s覺na sahiptirler. (pointer vb.)
          Bu nedenle, ge癟miten gelen d羹羹k donan覺mlar覺 y繹netmek i癟in performansa dayal覺 bir teknoloji diline ihtiya癟
          duyulduunda C++ ve C tercih edilir. Bu diller donan覺m覺n g羹c羹n羹 verimli bir ekilde kullanabilen kod
          par癟ac覺klar覺 oluturma hedefi ta覺rlar.
          Bu nedenle, savunma sanayisi, oyun end羹strisi, otonom ara癟 teknolojileri, iletim sistemleri, arama
          motorlar覺, haberleme gibi kilit alanlarda yayg覺n olarak kullan覺lmaktad覺rlar. rnek vermek gerekirse aktif
          olarak C, C++ teknolojisi kullanan
          yaz覺l覺mlar i癟in Linux(Core), Windows, Firefox, Adobe gibi 繹rnekler verilebilir.
        </p>
        <p>
          Ancak bu 繹zellikleri nedeniyle C++ dier dillere g繹re daha karma覺k bir syntax yap覺s覺na sahip ve daha fazla
          d羹羹k seviyeli donan覺m bilgisi gerektiren bir dildir. Performans ve verimlilik s繹z konusu olduunda,
          <b>doru ekilde yaz覺lm覺 ve mimari olarak implemente
            edilmi bir C, C++ kodu</b> olduk癟a yararl覺 olabilir. Ancak bu konuda bir癟ok noktaya dikkat edilmesi
          gerektii i癟in hataya daha fazla a癟覺k bir dil haline gelebilir. imdi genel bir bak覺 a癟覺s覺 sunduktan sonra
          konuyu daha da 繹zelletirebiliriz.
        </p>
        <h3>"New" Deyimini Kulland覺覺m覺zda Neler Ger癟ekleir?</h3>
        <p>
          "Neden daha az kullanmal覺y覺z?" sorusuna doru bir cevap verebilmek i癟in C++ dilinin genel yap覺s覺 hakk覺nda
          bilgi sahibi olmak ve "new" kullan覺m覺 sonras覺 bellek olaylar覺n覺n sonu癟lar覺n覺 bilmek 繹nemlidir.
        </p>

        <ul>
          <p>癟 tip bellek y繹netim tipi vard覺r:</p>
          <li>
            <p><b> - Static Memory Allocation | Statik Bellek Ay覺rma</b></p>
          </li>
          <p>&emsp;&emsp;
            Program覺n balat覺lmas覺ndan 繹nce "static" olarak tan覺mlanm覺 deerler i癟in bellek alan覺ndan yer tahsisi
            yap覺l覺r. Bu tahsis ilemi sadece bir kez ger癟ekletirilir ve deerler sabit boyutludur. Program sonlanana
            kadar bellek i癟erisinde yer al覺rlar,
            program覺n sonlanmas覺yla birlikte beraber bellee iade edilirler.
          </p>
          <li>
            <p><b> - Automatic Memory Allocation | Otomatik Bellek Ay覺rma</b></p>
          </li>
          <p>&emsp;&emsp;
            Lokal deikenler ve fonksiyon/method tan覺mlar覺 genellikle bir alanda balat覺l覺r ve ayn覺 alandan 癟覺kt覺ktan
            sonra bellekte iade edilir. Bu veriler <b>"Stack | Y覺覺n"</b> olarak adland覺r覺lan bir yap覺da saklan覺r ve
            iadeleri de bu ekilde
            ger癟ekletirilir. Bu bellek y繹netim bi癟imi i癟in daha g羹venli olduu d羹羹ncesi hakimdir.
          </p>
          <li>
            <p><b> - Dynamic Memory Allocation | Dinamik Bellek Ay覺rma</b></p>
          </li>
          <p>&emsp;&emsp;
            "new, malloc, calloc" gibi 癟ar覺lar ile bellek 羹zerinden anl覺k olarak alan tahsisi yap覺lmas覺 s繹z
            konusudur. Bellein tahsisi ve iadesi programc覺ya bal覺d覺r. Bu sebeple hataya a癟覺k ve dikkatli
            kullan覺lmas覺 gerekir. Tan覺mlanan deikenler ve objeler
            bellek 羹zerinde "heap" ad覺n覺 verdiimiz alanda tutulur. Bu k覺s覺m program 癟al覺t覺覺 s羹re zarf覺nda bellek
            alan覺ndan tahsis edilir ve kullan覺l覺r. Bu sebeple iletim adresi ve uzunluu sabit deildir. Program
            ileyiinde istenen yer ve oluan verinin b羹y羹kl羹羹
            ile deiicidir.
          </p>
          <p><b>
              Bu yaz覺n覺n temel konusu ise tan覺mlama ve kullan覺m bi癟imi dorultusunda ger癟ekleen "Automatic Memory
              Allocation | Otomatik Bellek Ay覺rma" ve "Dynamic Memory Allocation | Dinamik Bellek Ay覺rma" bi癟imlerinin
              farkl覺l覺klar覺ndan olumaktad覺r.
            </b></p>
        </ul>
        <img src="../../images/blogs/C++_Ile_Gelistirme_Yap._Neden_new_En_Aza_Ind/MemoryAllocation.webp"
          class="img-fluid" alt="Memory Allocation">
        <p style="text-align: center;">Kaynak: <a
            href="https://www.digikey.com/en/maker/projects/introduction-to-rtos-solution-to-part-4-memory-management/6d4dfcaa1ff84f57a2098da8e6401d9c">digiKey</a>
        </p>
        <p>
          imdi bellek alanlar覺n覺n tahsisinde ger癟ekleen farkl覺l覺klarla birlikte performans ve g羹venilirlik i癟in
          oluan durumlara g繹z atal覺m. Herhangi bir kod par癟aca覺n覺z i癟erisinde yaln覺zca "new" deyimiyle 癟ar覺
          yapt覺覺n覺zda bellek 羹zerinden bir alan tahsisi
          ger癟ekletirirsiniz, ayr覺ca bu alan覺n y繹netimi ve idaresi (C, C++ gibi programlama dilleri i癟in) sizlerin
          y繹netimindedir. <b>Bellee iadesi de 繹yle! Asla unutmamak gerekir. C ve C++ kaynak y繹netimi i癟in bir Garbage
            Collector'a sahip deildir.</b> Bu sebeple
          kullan覺lmayan deiken ve deerleri otomatik olarak iade ilemi ger癟ekletirmez, s羹reci y繹netmez. Bunun
          sebebi ise yukar覺da bahsetmi olduum eskiye d繹n羹k mimarisi, performans istei gibi 癟eitli sebeplerden
          kaynaklanmaktad覺r. Hatal覺 kullan覺m ile birlikte
          bellek 羹zerinden tahsis ettiiniz alan覺 iade etmememiz sonucunda "Memory Leak" ad覺n覺 verdiimiz durum ile
          kar覺laabilir veya program覺n覺z覺 kullan覺lamayan bir hale getirebilirsiniz.
        <div style="text-align: center;">
          <img style="height: 40%; width: 40%;"
            src="../../images/blogs/C++_Ile_Gelistirme_Yap._Neden_new_En_Aza_Ind/Error.webp" class="img-fluid"
            alt="Fail Case Robot">
        </div>
        </p>

        <h3>Memory Leak | Bellek S覺z覺nt覺s覺 襤癟in Basit Bir rnek</h3>
        <p><b>imdi bu durum i癟in basit bir 繹rnek 羹zerinden inceleyelim.</b></p>

        <!-- Youtube Video Content -->
        <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; margin-bottom: 3%;">
          <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
            src="https://www.youtube-nocookie.com/embed/Rb3NqsrzMKo?si=6lM9Js3VZPIwVWcb" title="YouTube video player"
            frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            allowfullscreen></iframe>
        </div>

        <p>
          rnek 羹zerinden gidecek olursak yukar覺daki kod par癟aca覺nda g繹r羹ld羹羹 羹zere bir "MyClass" ad覺yla bir s覺n覺f
          tan覺ml覺, bu s覺n覺ftan bir nesne oluturuyoruz ve "delete" ilemi ger癟ekletirilmeden if art覺 i癟erisinde yer
          alan return ile program覺 sonland覺r覺yoruz. G繹r羹ld羹羹 羹zere "MyClass"
          s覺n覺f覺na ait "Destructor | Y覺k覺c覺" herhangi bir ekilde 癟ar覺lm覺yor. Son durumda tan覺mlam覺 olduumuz class
          nesnesi halen bellekte yer almaya devam ediyor. Bu durum u an i癟in korkutucu g繹z羹kmeyebilir. Fakat eer bu
          par癟ac覺覺 癟ok fazla 癟al覺t覺r覺rsam? Bir s羹re zarf覺 sonras覺nda
          belleimde alan kalmayacak ve iletim sistemi 羹zerinden dier programlar, s羹re癟ler hatal覺 davranmaya, belki
          de sonlanmaya balayacakt覺r. Ayr覺ca kritik bir noktada b覺rak覺lan bu tip bir veri g羹venlik ihlali de
          oluturabilir. rnein bir kullan覺c覺ya ait tan覺ml覺 bir veriyi bir class yap覺s覺ndan
          oluturduunuz obje yard覺m覺yla tutuyorsunuz. Bu objeyi eer doru bi癟imde bellee iade etmez veya i癟eriini
          karartmazsan覺z bellek 羹zerinde okunabilir olarak kalacakt覺r.
        </p>
        <p>
          <b>! C ve C++ bellek y繹netimi i癟in sizlere farkl覺 yollar sunuyor fakat "Garbage Collector" bulunmay覺覺yla
            birlikte y繹netimin t羹m sorumluluunu da size devrediyor.</b>
        </p>


        <h3>Peki! 繹z羹m Yolu Nedir?</h3>
        <p>
          C++ bizlere bu durum i癟in <b>"Smart Pointers | Ak覺ll覺 襤aret癟iler"</b> gibi bir yol sunuyor. Yapt覺覺m覺z
          "new" tan覺mlar覺n覺n "Dynamic Memory Allocation | Dinamik Bellek Ay覺rma" yerine "Automatic Memory Allocation |
          Otomatik Bellek Ay覺rma" ile ger癟eklemesini
          salayabilirsiniz. Program覺n覺z覺n performans覺 ve kaynak y繹netimi i癟in bu yol sizlere daha iyi sonu癟lar
          verecektir. Detayland覺rmadan 繹nce ayn覺 繹rnei bir smart pointer yard覺m覺yla ger癟ekletirelim;
        </p>

        <!-- Youtube Video Content -->
        <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; margin-bottom: 3%;">
          <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
            src="https://www.youtube-nocookie.com/embed/yFzypPU3Q4I?si=hwZozFSsMxmbFcQX" title="YouTube video player"
            frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            allowfullscreen></iframe>
        </div>

        <p>
          Bu 繹rnek 羹zerinden bakt覺覺m覺zda ise if art覺 i癟erisinde program return ettiinde var olan deiken deeri
          i癟in bellek alan覺 iade ediliyor. 羹nk羹 "Destructor | Y覺k覺c覺" 癟ar覺s覺n覺n ger癟ekletiini g繹r羹yoruz. Ayr覺ca
          nesnenin bellek adresi boalt覺larak yeniden kullan覺lmak 羹zere tahsis ediliyor.
        </p>

        <h3>Neden Smart Pointer?</h3>
        <p><b>Dynamic Memory Allocation | Dinamik Bellek Ay覺rma VS Automatic Memory Allocation | Otomatik Bellek
            Ay覺rma</b></p>
        <p>
          Otomatik Bellek Ay覺rma ilemi, Dinamik Bellek Ay覺rma ilemine k覺yasla daha h覺zl覺 ve g羹venlidir. "heap"
          yap覺s覺 i癟in adresler deiicidir ve bellek alan覺nda s覺ral覺 deildirler. Adresci kay覺tlar覺n覺n tutulmas覺 ve
          deerlere eriim maliyetlidir. Bu maliyetler beraberinde performans kayb覺na yol a癟ar.
          Otomatik Bellek Ay覺rma ileminde yer alan "stack" yap覺s覺 i癟in ise deerler "FILO (First In Last Out)" olarak
          tutulduundan eriim h覺zl覺d覺r ve kay覺tl覺 adresci defteri boyutu azd覺r. Bellek 羹zerinden veriye erime
          maliyeti d羹羹kt羹r ve deikenlerin adres tan覺mlar覺 bir y覺覺n halinde tutulduundan
          deikenlerin, verilerin iadesinde "Memory Leak" hatalar覺n覺n 繹n羹ne ge癟er.
        </p>

        <h3>Sonu癟</h3>
        <p>
          "New" deyimini kullanmaktan her zaman ka癟覺nmak zorunda deilsiniz. zellikle y覺覺n boyutuna oranla daha
          fazla veri alman覺z gerektiinde veya new ifadesinin iadesini iyi y繹netebileceiniz durumlarda "new"
          kullanabilirsiniz.
          Ancak m羹mk羹n olduunca "Smart Pointers | Ak覺ll覺 襤aret癟ileri" kullanman覺z bellek kaynaklar覺n覺 daha iyi
          y繹netmenize yard覺mc覺 olarak program覺n覺z覺n erken "return" etmesi veya bir exception durumu
          olumas覺 durumunda size yard覺mc覺 olacakt覺r. S覺n覺f yap覺lar覺 olutururken ak覺ll覺 iaret癟iler ayr覺ca 癟ok
          kullan覺l覺 olabilirler. 羹nk羹 birden fazla ak覺ll覺 iaret癟i t羹r羹 vard覺r. Bu iaret癟ileri ie ve duruma 繹zg羹
          kullanabilirsiniz. TheCherno kanal覺na ait
          "<a href="https://www.youtube.com/watch?v=UOB7-B2MfwA">SMART POINTERS in C++ (std::unique_ptr,
            std::shared_ptr, std::weak_ptr)</a>" ve CoffeeBeforeArch kanal覺na ait <a
            href="https://youtu.be/LU62nNsigjs"> C++ Best Practices: RAII </a> i癟eriklerini izleyerek daha fazla bilgi
          edinebilirsiniz.
        </p>
        <p>
        <h3>Kaynak癟a</h3>
        <a href="https://stackoverflow.com/questions/6500313/why-should-c-programmers-minimize-use-of-new">Stackoverflow
          | Why should C++ programmers minimize use of 'new'?</a><br>
        <a href="https://stackoverflow.com/questions/147130/why-doesnt-c-have-a-garbage-collector">Stackoverflow | Why
          doesn't C++ have a garbage collector?</a><br>
        <a href="https://www.youtube.com/watch?v=UOB7-B2MfwA">SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr,
          std::weak_ptr)</a><br>
        <a
          href="https://www.digikey.com/en/maker/projects/introduction-to-rtos-solution-to-part-4-memory-management/6d4dfcaa1ff84f57a2098da8e6401d9c">DigiKey
          | Introduction to RTOS - Solution to Part
          4 (Memory Management)</a><br>
        <a
          href="https://ptolemy.berkeley.edu/ptolemyclassic/almagest/docs/prog/html/ptlang.doc7.html#:~:text=Memory%20leaks%20occur%20when%20new,or%20the%20delete%20%5B%5D%20operator.">2.7
          Preventing
          Memory Leaks in C++ Code</a><br>
        </p>
      </div>
    </div>
  </section>

  <!-- Contact -->
  <section id="contact-container"></section>
  <script>
    fetch('/pages/page_partial/contact.html')
      .then(response => response.text())
      .then(data => {
        document.getElementById('contact-container').innerHTML = data;
      });
  </script>

  <script src="/js/jquery-3.3.1.min.js"></script>
  <script src="/js/popper.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script src="/js/Headroom.js"></script>
  <script src="/js/jQuery.headroom.js"></script>
  <script src="/js/owl.carousel.min.js"></script>
  <script src="/js/theme-and-loader.js"></script>

</body>

</html>