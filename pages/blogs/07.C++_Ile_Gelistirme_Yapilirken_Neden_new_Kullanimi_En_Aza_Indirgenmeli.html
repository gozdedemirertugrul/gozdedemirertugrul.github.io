<!doctype html>
<html lang="tr">

<head>
  <!-- Tab Info -->
  <title>Kağan Can Şit</title>
  <link rel="icon" href="/images/baseSiteImages/designPng.png" type="image/x-icon" />
  <!-- Include js script and include header -->
  <script src="/js/dynamic_content.js"></script>
  <div id="site_header"></div>
</head>

<body>
  <!-- MENU -->
  <nav class="navbar navbar-expand-sm navbar-light">
    <div class="container">
      <a class="navbar-brand" href="/index.html"> Kağan Can Şit</a>

      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
        aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
        <span class="navbar-toggler-icon"></span>
        <span class="navbar-toggler-icon"></span>
      </button>

      <div style="background-color: transparent;" class="collapse navbar-collapse" id="navbarNav">

        <!-- Insert Navbar Content -->
        <div class="mx-auto" id="site_navbar"></div>
        <ul class="navbar-nav ml-lg-auto">
          <a class="nav-link"><span data-hover="Renk Modu" class="color-mode color-mode-icon"></span></a>
        </ul>
      </div>
    </div>
  </nav>

  <!-- Blog -->
  <section class="project py-5" id="project">
    <div class="container">
      <div class="row">
        <div class="col-lg-11 mx-auto col-12">
          <div class="about-image svg">
            <img src="../../images/blogs/C++_Ile_Gelistirme_Yap._Neden_new_En_Aza_Ind/header_image.png"
              class="img-fluid" alt="svg image"><br><br>
          </div>
        </div>
        <div class="col-lg-12 mx-auto">
          <h2>C++ İle Geliştirme Yapılırken Neden "new" Kullanımı En Aza İndirgenmeli?</h2>
          <p><small>Mart 12, 2023</small></p>
          <p>
            Merhaba, bugün C++ dilinde "new" kullanımının arkasında neler olduğuna dair bir bakış atacağız. C++ ve C
            donanım tabanlı birçok amaç için kullanılabilen dillerdir ve bellek yönetimi konusunda biraz daha açık yazım
            yapısına sahiptirler. (pointer vb.)
            Bu nedenle, geçmişten gelen düşük donanımları yönetmek için performansa dayalı bir teknoloji diline ihtiyaç
            duyulduğunda C++ ve C tercih edilir. Bu diller donanımın gücünü verimli bir şekilde kullanabilen kod
            parçacıkları oluşturma hedefi taşırlar.
            Bu nedenle, savunma sanayisi, oyun endüstrisi, otonom araç teknolojileri, işletim sistemleri, arama
            motorları, haberleşme gibi kilit alanlarda yaygın olarak kullanılmaktadırlar. Örnek vermek gerekirse aktif
            olarak C, C++ teknolojisi kullanan
            yazılımlar için Linux(Core), Windows, Firefox, Adobe gibi örnekler verilebilir.
          </p>
          <p>
            Ancak bu özellikleri nedeniyle C++ diğer dillere göre daha karmaşık bir syntax yapısına sahip ve daha fazla
            düşük seviyeli donanım bilgisi gerektiren bir dildir. Performans ve verimlilik söz konusu olduğunda,
            <b>doğru şekilde yazılmış ve mimari olarak implemente
              edilmiş bir C, C++ kodu</b> oldukça yararlı olabilir. Ancak bu konuda birçok noktaya dikkat edilmesi
            gerektiği için hataya daha fazla açık bir dil haline gelebilir. Şimdi genel bir bakış açısı sunduktan sonra
            konuyu daha da özelleştirebiliriz.
          </p>
          <h3>"New" Deyimini Kullandığımızda Neler Gerçekleşir?</h2>
            <p>
              "Neden daha az kullanmalıyız?" sorusuna doğru bir cevap verebilmek için C++ dilinin genel yapısı hakkında
              bilgi sahibi olmak ve "new" kullanımı sonrası bellek olaylarının sonuçlarını bilmek önemlidir.
            </p>
            <p>
              Üç tip bellek yönetim tipi vardır: <br>
            <ul>
              <li>
                <p><b>&emsp;-> Static Memory Allocation | Statik Bellek Ayırma</b></p>
              </li>
              <p>&emsp;&emsp;
                Programın başlatılmasından önce "static" olarak tanımlanmış değerler için bellek alanından yer tahsisi
                yapılır. Bu tahsis işlemi sadece bir kez gerçekleştirilir ve değerler sabit boyutludur. Program
                sonlanana kadar bellek içerisinde yer alırlar,
                programın sonlanmasıyla birlikte beraber belleğe iade edilirler.
              </p>
              <li>
                <p><b>&emsp;-> Automatic Memory Allocation | Otomatik Bellek Ayırma</b></p>
              </li>
              <p>&emsp;&emsp;
                Lokal değişkenler ve fonksiyon/method tanımları genellikle bir alanda başlatılır ve aynı alandan
                çıktıktan sonra bellekte iade edilir. Bu veriler <b>"Stack | Yığın"</b> olarak adlandırılan bir yapıda
                saklanır ve iadeleri de bu şekilde
                gerçekleştirilir. Bu bellek yönetim biçimi için daha güvenli olduğu düşüncesi hakimdir.
              </p>
              <li>
                <p><b>&emsp;-> Dynamic Memory Allocation | Dinamik Bellek Ayırma</b></p>
              </li>
              <p>&emsp;&emsp;
                "new, malloc, calloc" gibi çağrılar ile bellek üzerinden anlık olarak alan tahsisi yapılması söz
                konusudur. Belleğin tahsisi ve iadesi programcıya bağlıdır. Bu sebeple hataya açık ve dikkatli
                kullanılması gerekir. Tanımlanan değişkenler ve objeler
                bellek üzerinde "heap" adını verdiğimiz alanda tutulur. Bu kısım program çalıştığı süre zarfında bellek
                alanından tahsis edilir ve kullanılır. Bu sebeple işletim adresi ve uzunluğu sabit değildir. Program
                işleyişinde istenen yer ve oluşan verinin büyüklüğü
                ile değişicidir.
              </p>
              <p><b>Bu yazının temel konusu ise tanımlama ve kullanım biçimi doğrultusunda gerçekleşen "Automatic Memory
                  Allocation | Otomatik Bellek Ayırma" ve "Dynamic Memory Allocation | Dinamik Bellek Ayırma"
                  biçimlerinin farklılıklarından oluşmaktadır.</b></p>
            </ul>
            <div style="text-align: center;">
              <img src="../../images/blogs/C++_Ile_Gelistirme_Yap._Neden_new_En_Aza_Ind/MemoryAllocation.jpeg"
                class="img-fluid" alt="Memory Allocation">
              <p style="text-align: center;">Kaynak: <a
                  href="https://www.digikey.com/en/maker/projects/introduction-to-rtos-solution-to-part-4-memory-management/6d4dfcaa1ff84f57a2098da8e6401d9c">digiKey</a>
              </p>
            </div>
            </p>

            <p>
              Şimdi bellek alanlarının tahsisinde gerçekleşen farklılıklarla birlikte performans ve güvenilirlik için
              oluşan durumlara göz atalım. Herhangi bir kod parçacağınız içerisinde yalnızca "new" deyimiyle çağrı
              yaptığınızda bellek üzerinden bir alan tahsisi
              gerçekleştirirsiniz, ayrıca bu alanın yönetimi ve idaresi (C, C++ gibi programlama dilleri için) sizlerin
              yönetimindedir. <b>Belleğe iadesi de öyle! Asla unutmamak gerekir. C ve C++ kaynak yönetimi için bir
                Garbage Collector'a sahip değildir.</b> Bu sebeple
              kullanılmayan değişken ve değerleri otomatik olarak iade işlemi gerçekleştirmez, süreci yönetmez. Bunun
              sebebi ise yukarıda bahsetmiş olduğum eskiye dönük mimarisi, performans isteği gibi çeşitli sebeplerden
              kaynaklanmaktadır. Hatalı kullanım ile birlikte
              bellek üzerinden tahsis ettiğiniz alanı iade etmememiz sonucunda "Memory Leak" adını verdiğimiz durum ile
              karşılaşabilir veya programınızı kullanılamayan bir hale getirebilirsiniz.
            <div style="text-align: center;">
              <img style="height: 40%; width: 40%;"
                src="../../images/blogs/C++_Ile_Gelistirme_Yap._Neden_new_En_Aza_Ind/Error.png" class="img-fluid"
                alt="Fail Case Robot">
            </div>
            </p>

            <p>
            <h3>Memory Leak | Bellek Sızıntısı İçin Basit Bir Örnek</h3>
            <p><b>Şimdi bu durum için basit bir örnek üzerinden inceleyelim.</b></p>
            </p>
            <p>
              <video width="100%" height="100%" controls="controls">
                <source src="../../images/blogs/C++_Ile_Gelistirme_Yap._Neden_new_En_Aza_Ind/OnlyNew.mp4"
                  type="video/mp4" />
                <source src="video.ogg" type="video/ogg" />
                Tarayıcınız video etiketini desteklemiyor.
              </video>
            </p>
            <p>
              Örnek üzerinden gidecek olursak yukarıdaki kod parçacağında görüldüğü üzere bir "MyClass" adıyla bir sınıf
              tanımlı, bu sınıftan bir nesne oluşturuyoruz ve "delete" işlemi gerçekleştirilmeden if şartı içerisinde
              yer alan return ile programı sonlandırıyoruz. Görüldüğü üzere "MyClass"
              sınıfına ait "Destructor | Yıkıcı" herhangi bir şekilde çağrılmıyor. Son durumda tanımlamış olduğumuz
              class nesnesi halen bellekte yer almaya devam ediyor. Bu durum şu an için korkutucu gözükmeyebilir. Fakat
              eğer bu parçacığı çok fazla çalıştırırsam? Bir süre zarfı sonrasında
              belleğimde alan kalmayacak ve işletim sistemi üzerinden diğer programlar, süreçler hatalı davranmaya,
              belki de sonlanmaya başlayacaktır. Ayrıca kritik bir noktada bırakılan bu tip bir veri güvenlik ihlali de
              oluşturabilir. Örneğin bir kullanıcıya ait tanımlı bir veriyi bir class yapısından
              oluşturdupğunuz obje yardımıyla tutuyorsunuz. Bu objeyi eğer doğru biçimde belleğe iade etmez veya
              içeriğini karartmazsanız bellek üzerinde okunabilir olarak kalacaktır.
            </p>
            <p>
              <b>! C ve C++ bellek yönetimi için sizlere farklı yollar sunuyor fakat "Garbage Collector" bulunmayışıyla
                birlikte yönetimin tüm sorumluluğunu da size devrediyor.</b>
            </p>


            <h3>Peki! Çözüm Yolu Nedir?</h3>
            <p>
              C++ bizlere bu durum için <b>"Smart Pointers | Akıllı İşaretçiler"</b> gibi bir yol sunuyor. Yaptığımız
              "new" tanımlarının "Dynamic Memory Allocation | Dinamik Bellek Ayırma" yerine "Automatic Memory Allocation
              | Otomatik Bellek Ayırma" ile gerçekleşmesini
              sağlayabilirsiniz. Programınızın performansı ve kaynak yönetimi için bu yol sizlere daha iyi sonuçlar
              verecektir. Detaylandırmadan önce aynı örneği bir smart pointer yardımıyla gerçekleştirelim;
            </p>
            <p>
              <video width="100%" height="100%" controls="controls">
                <source src="../../images/blogs/C++_Ile_Gelistirme_Yap._Neden_new_En_Aza_Ind/SmartPointers.mp4"
                  type="video/mp4" />
                <source src="video.ogg" type="video/ogg" />
                Tarayıcınız video etiketini desteklemiyor.
              </video>
            </p>
            <p>
              Bu örnek üzerinden baktığımızda ise if şartı içerisinde program return ettiğinde var olan değişken değeri
              için bellek alanı iade ediliyor. Çünkü "Destructor | Yıkıcı" çağrısının gerçekleştiğini görüyoruz. Ayrıca
              nesnenin bellek adresi boşaltılarak yeniden kullanılmak üzere tahsis ediliyor.
            </p>

            <h3>Neden Smart Pointer?</h3>
            <p>&emsp; -> Dynamic Memory Allocation | Dinamik Bellek Ayırma VS Automatic Memory Allocation | Otomatik
              Bellek Ayırma</b></p>
            <p>
              Otomatik Bellek Ayırma işlemi, Dinamik Bellek Ayırma işlemine kıyasla daha hızlı ve güvenlidir. "heap"
              yapısı için adresler değişicidir ve bellek alanında sıralı değildirler. Adresci kayıtlarının tutulması ve
              değerlere erişim maliyetlidir. Bu maliyetler beraberinde performans kaybına yol açar.
              Otomatik Bellek Ayırma işleminde yer alan "stack" yapısı için ise değerler "FILO (First In Last Out)"
              olarak tutulduğundan erişim hızlıdır ve kayıtlı adresci defteri boyutu azdır. Bellek üzerinden veriye
              erişme maliyeti düşüktür ve değişkenlerin adres tanımları bir yığın halinde tutulduğundan
              değişkenlerin, verilerin iadesinde "Memory Leak" hatalarının önüne geçer.
            </p>

            <h3>Sonuç</h3>
            <p>
              "New" deyimini kullanmaktan her zaman kaçınmak zorunda değilsiniz. Özellikle yığın boyutuna oranla daha
              fazla veri almanız gerektiğinde veya new ifadesinin iadesini iyi yönetebileceğiniz durumlarda "new"
              kullanabilirsiniz.
              Ancak mümkün olduğunca "Smart Pointers | Akıllı İşaretçileri" kullanmanız bellek kaynaklarını daha iyi
              yönetmenize yardımcı olarak programınızın erken "return" etmesi veya bir exception durumu
              oluşması durumunda size yardımcı olacaktır. Sınıf yapıları oluştururken akıllı işaretçiler ayrıca çok
              kullanışlı olabilirler. Çünkü birden fazla akıllı işaretçi türü vardır. Bu işaretçileri işe ve duruma özgü
              kullanabilirsiniz. TheCherno kanalına ait
              "<a href="https://www.youtube.com/watch?v=UOB7-B2MfwA">SMART POINTERS in C++ (std::unique_ptr,
                std::shared_ptr, std::weak_ptr)</a>" videosunu izleyerek daha fazla bilgi edinebilirsiniz.
            </p>
            <p>
            <h3>Kaynakça</h3>
            <a href="https://stackoverflow.com/questions/6500313/why-should-c-programmers-minimize-use-of-new">Stackoverflow
              | Why should C++ programmers minimize use of 'new'?</a><br>
            <a href="https://stackoverflow.com/questions/147130/why-doesnt-c-have-a-garbage-collector">Stackoverflow |
              Why doesn't C++ have a garbage collector?</a><br>
            <a href="https://www.youtube.com/watch?v=UOB7-B2MfwA">SMART POINTERS in C++ (std::unique_ptr,
              std::shared_ptr, std::weak_ptr)</a><br>
            <a
              href="https://www.digikey.com/en/maker/projects/introduction-to-rtos-solution-to-part-4-memory-management/6d4dfcaa1ff84f57a2098da8e6401d9c">DigiKey
              | Introduction to RTOS - Solution to Part 4 (Memory Management)</a><br>
            <a
              href="https://ptolemy.berkeley.edu/ptolemyclassic/almagest/docs/prog/html/ptlang.doc7.html#:~:text=Memory%20leaks%20occur%20when%20new,or%20the%20delete%20%5B%5D%20operator.">2.7
              Preventing Memory Leaks in C++ Code</a><br>
            </p>
        </div>
      </div>
    </div>
  </section>

  <!-- js Include Footer -->
  <div id="site_footer"></div>

  <!-- Other Scripts -->
  <script src="/js/jquery-3.3.1.min.js"></script>
  <script src="/js/popper.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script src="/js/Headroom.js"></script>
  <script src="/js/jQuery.headroom.js"></script>
  <script src="/js/owl.carousel.min.js"></script>
  <script src="/js/smoothscroll.js"></script>
  <script src="/js/custom.js"></script>
</body>
</html>